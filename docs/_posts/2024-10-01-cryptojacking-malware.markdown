---
layout: default
title:  "记录一次挖矿病毒处理"
date:   2024-10-01 00:00:00 +0800
categories:
---

# Background

It begins with a server running CentOS left poorly maintained for a long time,
the professor in charge is not an experienced Linux user so sometimes I have to help him with the issues.

A sshd service is exposed to the campus network, and occasionally attacked by brute force
(usually form another device in the campus network, presumably infected by some malware).
The service **allows** root login and password login, and no security measures like fail2ban are configured.

The campus network is a large LAN, and without logging in, you can't access the Internet (not entirely true).

The professor told me that it was once infected by a cryptomining malware due to weak passwords,
and someone was asked to clean it up.
However, whether the malware was completely removed remains unknown.


# Symptoms

- **Unusual CPU usage when connected to Internet**:
  Everything seems normal until the server got access to access the Internet.
  After that half of the CPU cores are occupied by some unknown processes.
  Once I logged out of the campus network, the CPU usage dropped to normal.

  **`htop` does not show any suspicious processes, neither does `perf top`**.

- **The missing `iptables`**:
  Once I found that the `/usr/sbin/iptables` was missing, which should be a symbolic link to `xtables-multi`.
  I thought it was just mistakenly removed by someone, so I recreated the link (I'm pretty sure I did).
  > [!NOTE]
  > If your system is well maintained, reinstalling the package is a better choice.

  However, it disappeared again after a reboot, which is quite suspicious.

# Investigation

## Malware?

I was quite confused about the null result of `htop`, as far as I know,
there is no user-space tool that can hide processes from `htop` or `ps`.
So I didn't thought of a malware at first, but rather some kernel bugs in network drivers.

When I noticed that the CPU usage was strongly related to the Internet connection,
kernel bugs seemed unlikely, for the traffic in and out of the campus network should not be that different for the kernel.

I ran `unhide` on the server,
which claims to detect hidden processes by comparing different sources of process information.
And there it is, couple of procfs entries are found.

```bash
$ ls -l /proc/???/exe
/proc/???/exe -> /41143d0f (deleted)
```
Which is definitely not a normal process.
The file on disk was deleted, but we are still able to dump it from procfs.
It was an unstripped ELF binary file, with many symbols with C++ namespace `xmrig::`,
which is a well-known cryptomining software.

## Persistence

Though the cryptomining worker was found, it was still unclear how it survived reboots.
The obvious ways are systemd services and cron jobs, but I didn't find any suspicious config files.
Examining the environment variables via `/proc/???/environ`
and `grep` the filesystem for the binary name didn't help either.

In fact, there is an easy way to examine which systemd unit a process belongs to.
Note that systemd by default uses cgroups to manage processes, e.g.:
```bash
$ cat /proc/$$/cgroup
0::/user.slice/user-1000.slice/session-1.scope

$ cat /proc/$(pidof NetworkManager)/cgroup
0::/system.slice/NetworkManager.service

# that server is using cgroup v1 with many lines, but you get the point
```
Which gives out the systemd unit name of the malware process `yayayad347cbd.service`.

~~Here I quote a meme from the AOSC OS community:~~
> ~~信任 systemd 的人~~  
> ~~最终会连底裤都卖给 systemd~~  
> ~~你卖掉一条底裤之后~~  
> ~~就会逐渐卖掉其余的底裤~~  
> ~~最终结果是一无所有~~  
> ~~试图做的大而全的东西~~  
> ~~最后都会被踢进历史的垃圾堆~~  

## Kernel module

To my surprise, `systemctl status` showed that the unit file in under `/usr/lib/systemd/system/`,
but when I `ls`, it was not there. So this does not explain the persistence of the malware?

Then to just make sure, I tried `stat` that file directly,
**and it did exist, I can also read the content, what the hell?**
```systemd
[Unit]
Description=Server Service
Wants=network-online.target
After=network-online.target

[Service]
Type=forking
User=root
ExecStart=/usr/lib/x86_64-linux-gnu/yayaya66444c21
Restart=always
RestartSec=4h

[Install]
WantedBy=multi-user.target
```
Any other file with the same name also became invisible to `ls`.

*Perhaps it somehow tricks the `ls` command or hooks into some `libc` functions to hide itself*, I thought.

Interestingly, the `rm` command also suffers,
```bash
$ touch foo/yayaya
$ rm -rv foo
rm: cannot remove 'foo', directory not empty
# Normally you can remove a non-empty directory with -r
# But somehow rm missed the file yayaya before trying to remove its parent directory
```

Things got more creepy when I tried to `strace` the `ls` command,
it told me that even the results of `getdents` syscall is intercepted.

Then I became desperate when I found the log of that unit saying:
```
make: Entering directory `/usr/src/kernels/3.10.0-1127.el7.x86_64'
CC [M]  /tmp/a/nonono.o
Building modules, stage 2.
MODPOST 1 modules
CC      /tmp/a/nonono.mod.o
LD [M]  /tmp/a/nonono.ko
```
Clearly the malware had been building and inserting a `nonono` kernel module, which is a very bad sign.
Everything I saw on that server by user-space tools could be unreliable.
The module was also hidden from `lsmod` and `modinfo`.

# Cleanup

The main executable of the malware under `/usr/lib/x86_64-linux-gnu/` can be run in a sandbox to see what it does.
And thankfully, I found some blog posts about the similar malware,
it mentioned that the kernel module is actually a rootkit named [Diamorphine](https://github.com/m0nad/Diamorphine).
According to its README, to unhide everything, you can simply send a signal to any process, e.g.:
```bash
$ kill -63 0
```
And then I can see the kernel module and remove it with `rmmod`, and the hidden files are also visible now.
It turned out that the malware simply changed the `MAGIC_PREFIX` to `yayaya`, without even removing the signal handler.

```
asmlinkage int
hacked_kill(const struct pt_regs *pt_regs)
{
	...
	switch (sig) {
case SIGMODINVIS:
			if (module_hidden) module_show();
			else module_hide();
			break;
	...
	}
}

static int __init
diamorphine_init(void)
{
	...
	__sys_call_table[__NR_getdents] = (unsigned long) hacked_getdents;
	__sys_call_table[__NR_getdents64] = (unsigned long) hacked_getdents64;
	__sys_call_table[__NR_kill] = (unsigned long) hacked_kill;
	...
}
```

